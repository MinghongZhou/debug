//
//  TransanctionsTable.swift
//  MySampleApp
//
//
// Copyright 2017 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to 
// copy, distribute and modify it.
//
// Source code generated from template: aws-my-sample-app-ios-swift v0.19
//

import Foundation
import UIKit
import AWSDynamoDB
import AWSAuthCore

class TransanctionsTable: NSObject, Table {
    
    var tableName: String
    var partitionKeyName: String
    var partitionKeyType: String
    var sortKeyName: String?
    var sortKeyType: String?
    var model: AWSDynamoDBObjectModel
    var indexes: [Index]
    var orderedAttributeKeys: [String] {
        return produceOrderedAttributeKeys(model)
    }
    var tableDisplayName: String {

        return "Transanctions"
    }
    
    override init() {

        model = Transanctions()
        
        tableName = model.classForCoder.dynamoDBTableName()
        partitionKeyName = model.classForCoder.hashKeyAttribute()
        partitionKeyType = "String"
        indexes = [

            TransanctionsPrimaryIndex(),

            TransanctionsLender(),

            TransanctionsBorrower(),
        ]
        if let sortKeyNamePossible = model.classForCoder.rangeKeyAttribute?() {
            sortKeyName = sortKeyNamePossible
            sortKeyType = "String"
        }
        super.init()
    }
    
    /**
     * Converts the attribute name from data object format to table format.
     *
     * - parameter dataObjectAttributeName: data object attribute name
     * - returns: table attribute name
     */

    func tableAttributeName(_ dataObjectAttributeName: String) -> String {
        return Transanctions.jsonKeyPathsByPropertyKey()[dataObjectAttributeName] as! String
    }
    
    func getItemDescription() -> String {
        let hashKeyValue = "demo-transactionId-3"
        let rangeKeyValue = "demo-transactionDate-500000"
        return "Find Item with transactionId = \(hashKeyValue) and transactionDate = \(rangeKeyValue)."
    }
    
    func getItemWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBObjectModel?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        objectMapper.load(Transanctions.self, hashKey: "demo-transactionId-3", rangeKey: "demo-transactionDate-500000") { (response: AWSDynamoDBObjectModel?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as NSError?)
            })
        }
    }
    
    func scanDescription() -> String {
        return "Show all items in the table."
    }
    
    func scanWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let scanExpression = AWSDynamoDBScanExpression()
        scanExpression.limit = 5

        objectMapper.scan(Transanctions.self, expression: scanExpression) { (response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as NSError?)
            })
        }
    }
    
    
    func insertSampleDataWithCompletionHandler(_ completionHandler: @escaping (_ errors: [NSError]?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        var errors: [NSError] = []
        let group: DispatchGroup = DispatchGroup()
        let numberOfObjects = 20
        

        let itemForGet: Transanctions! = Transanctions()
        
        itemForGet._transactionId = "demo-transactionId-3"
        itemForGet._transactionDate = "demo-transactionDate-500000"
        itemForGet._borrower = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
        itemForGet._lender = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
        
        
        group.enter()
        

        objectMapper.save(itemForGet, completionHandler: {(error: Error?) -> Void in
            if let error = error as? NSError {
                DispatchQueue.main.async(execute: {
                    errors.append(error)
                })
            }
            group.leave()
        })
        
        for _ in 1..<numberOfObjects {

            let item: Transanctions = Transanctions()
            item._transactionId = NoSQLSampleDataGenerator.randomPartitionSampleStringWithAttributeName("transactionId")
            item._transactionDate = NoSQLSampleDataGenerator.randomSampleStringWithAttributeName("transactionDate")
            item._borrower = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
            item._lender = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
            
            group.enter()
            
            objectMapper.save(item, completionHandler: {(error: Error?) -> Void in
                if error != nil {
                    DispatchQueue.main.async(execute: {
                        errors.append(error! as NSError)
                    })
                }
                group.leave()
            })
        }
        
        group.notify(queue: DispatchQueue.main, execute: {
            if errors.count > 0 {
                completionHandler(errors)
            }
            else {
                completionHandler(nil)
            }
        })
    }
    
    func removeSampleDataWithCompletionHandler(_ completionHandler: @escaping ([NSError]?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let scanExpression = AWSDynamoDBScanExpression()
        scanExpression.filterExpression = "begins_with(#transactionId, :transactionId)"
        scanExpression.expressionAttributeNames = ["#transactionId": "transactionId"]
        scanExpression.expressionAttributeValues = [":transactionId": "demo-"]

        objectMapper.scan(Transanctions.self, expression: scanExpression) { (response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            if let error = error as? NSError {
                DispatchQueue.main.async(execute: {
                    completionHandler([error]);
                    })
            } else {
                var errors: [NSError] = []
                let group: DispatchGroup = DispatchGroup()
                for item in response!.items {
                    group.enter()
                    objectMapper.remove(item, completionHandler: {(error: Error?) in
                        if let error = error as? NSError {
                            DispatchQueue.main.async(execute: {
                                errors.append(error)
                            })
                        }
                        group.leave()
                    })
                }
                group.notify(queue: DispatchQueue.main, execute: {
                    if errors.count > 0 {
                        completionHandler(errors)
                    }
                    else {
                        completionHandler(nil)
                    }
                })
            }
        }
    }
    
    func updateItem(_ item: AWSDynamoDBObjectModel, completionHandler: @escaping (_ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        

        let itemToUpdate: Transanctions = item as! Transanctions
        
        itemToUpdate._borrower = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
        itemToUpdate._lender = NoSQLSampleDataGenerator.randomPartitionSampleNumber()
        
        objectMapper.save(itemToUpdate, completionHandler: {(error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(error as? NSError)
            })
        })
    }
    
    func removeItem(_ item: AWSDynamoDBObjectModel, completionHandler: @escaping (_ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        
        objectMapper.remove(item, completionHandler: {(error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(error as? NSError)
            })
        })
    }
}

class TransanctionsPrimaryIndex: NSObject, Index {
    
    var indexName: String? {
        return nil
    }
    
    func supportedOperations() -> [String] {
        return [
            QueryWithPartitionKey,
            QueryWithPartitionKeyAndSortKey,
        ]
    }
    
    func queryWithPartitionKeyDescription() -> String {
        let partitionKeyValue = "demo-transactionId-3"
        return "Find all items with transactionId = \(partitionKeyValue)."
    }
    
    func queryWithPartitionKeyWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        
        queryExpression.keyConditionExpression = "#transactionId = :transactionId"
        queryExpression.expressionAttributeNames = ["#transactionId": "transactionId",]
        queryExpression.expressionAttributeValues = [":transactionId": "demo-transactionId-3",]

        objectMapper.query(Transanctions.self, expression: queryExpression) { (response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        }
    }
    
    func queryWithPartitionKeyAndSortKeyDescription() -> String {
        let partitionKeyValue = "demo-transactionId-3"
        let sortKeyValue = "demo-transactionDate-500000"
        return "Find all items with transactionId = \(partitionKeyValue) and transactionDate < \(sortKeyValue)."
    }
    
    func queryWithPartitionKeyAndSortKeyWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        
        queryExpression.keyConditionExpression = "#transactionId = :transactionId AND #transactionDate < :transactionDate"
        queryExpression.expressionAttributeNames = [
            "#transactionId": "transactionId",
            "#transactionDate": "transactionDate",
        ]
        queryExpression.expressionAttributeValues = [
            ":transactionId": "demo-transactionId-3",
            ":transactionDate": "demo-transactionDate-500000",
        ]
        

        objectMapper.query(Transanctions.self, expression: queryExpression, completionHandler: {(response: AWSDynamoDBPaginatedOutput?, error: Error?) -> Void in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        })
    }
    
}

class TransanctionsLender: NSObject, Index {
    
    var indexName: String? {

        return "lender"
    }
    
    func supportedOperations() -> [String] {
        return [
            QueryWithPartitionKey,
            QueryWithPartitionKeyAndFilter,
        ]
    }
    
    func queryWithPartitionKeyDescription() -> String {
        let partitionKeyValue = 1111000003
        return "Find all items with lender = \(partitionKeyValue)."
    }
    
    func queryWithPartitionKeyWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        

        queryExpression.indexName = "lender"
        queryExpression.keyConditionExpression = "#lender = :lender"
        queryExpression.expressionAttributeNames = ["#lender": "lender",]
        queryExpression.expressionAttributeValues = [":lender": 1111000003,]

        objectMapper.query(Transanctions.self, expression: queryExpression) { (response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        }
    }
    
    func queryWithPartitionKeyAndFilterDescription() -> String {
        let partitionKeyValue = 1111000003
        let filterAttributeValue = "demo-transactionDate-500000"
        return "Find all items with lender = \(partitionKeyValue) and transactionDate > \(filterAttributeValue)."
    }
    
    func queryWithPartitionKeyAndFilterWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        

        queryExpression.indexName = "lender"
        queryExpression.keyConditionExpression = "#lender = :lender"
        queryExpression.filterExpression = "#transactionDate > :transactionDate"
        queryExpression.expressionAttributeNames = [
            "#lender": "lender",
            "#transactionDate": "transactionDate",
        ]
        queryExpression.expressionAttributeValues = [
            ":lender": 1111000003,
            ":transactionDate": "demo-transactionDate-500000",
        ]
        

        objectMapper.query(Transanctions.self, expression: queryExpression, completionHandler: {(response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        })
    }
    
}

class TransanctionsBorrower: NSObject, Index {
    
    var indexName: String? {

        return "borrower"
    }
    
    func supportedOperations() -> [String] {
        return [
            QueryWithPartitionKey,
            QueryWithPartitionKeyAndFilter,
        ]
    }
    
    func queryWithPartitionKeyDescription() -> String {
        let partitionKeyValue = 1111000003
        return "Find all items with borrower = \(partitionKeyValue)."
    }
    
    func queryWithPartitionKeyWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        

        queryExpression.indexName = "borrower"
        queryExpression.keyConditionExpression = "#borrower = :borrower"
        queryExpression.expressionAttributeNames = ["#borrower": "borrower",]
        queryExpression.expressionAttributeValues = [":borrower": 1111000003,]

        objectMapper.query(Transanctions.self, expression: queryExpression) { (response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        }
    }
    
    func queryWithPartitionKeyAndFilterDescription() -> String {
        let partitionKeyValue = 1111000003
        let filterAttributeValue = "demo-transactionDate-500000"
        return "Find all items with borrower = \(partitionKeyValue) and transactionDate > \(filterAttributeValue)."
    }
    
    func queryWithPartitionKeyAndFilterWithCompletionHandler(_ completionHandler: @escaping (_ response: AWSDynamoDBPaginatedOutput?, _ error: NSError?) -> Void) {
        let objectMapper = AWSDynamoDBObjectMapper.default()
        let queryExpression = AWSDynamoDBQueryExpression()
        

        queryExpression.indexName = "borrower"
        queryExpression.keyConditionExpression = "#borrower = :borrower"
        queryExpression.filterExpression = "#transactionDate > :transactionDate"
        queryExpression.expressionAttributeNames = [
            "#borrower": "borrower",
            "#transactionDate": "transactionDate",
        ]
        queryExpression.expressionAttributeValues = [
            ":borrower": 1111000003,
            ":transactionDate": "demo-transactionDate-500000",
        ]
        

        objectMapper.query(Transanctions.self, expression: queryExpression, completionHandler: {(response: AWSDynamoDBPaginatedOutput?, error: Error?) in
            DispatchQueue.main.async(execute: {
                completionHandler(response, error as? NSError)
            })
        })
    }
    
}
